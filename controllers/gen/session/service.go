// Code generated by goa v3.0.6, DO NOT EDIT.
//
// session service
//
// Command:
// $ goa gen github.com/anshap1719/authentication/design

package session

import (
	"context"

	sessionviews "github.com/anshap1719/authentication/controllers/gen/session/views"
	goa "goa.design/goa/v3/pkg"
	"goa.design/goa/v3/security"
)

// Service is the session service interface.
type Service interface {
	// Take a user's session token and refresh it, also returns a new
	// authentication token
	Refresh(context.Context, *RefreshPayload) (res *RefreshResult, err error)
	// Takes a user's auth token, and logs-out the session associated with it
	Logout(context.Context, *LogoutPayload) (err error)
	// Logout all sessions for the current user except their current session
	LogoutOther(context.Context, *LogoutOtherPayload) (err error)
	// Logout of a specific session
	LogoutSpecific(context.Context, *LogoutSpecificPayload) (err error)
	// Gets all of the sessions that are associated with the currently logged in
	// user
	GetSessions(context.Context, *GetSessionsPayload) (res *AllSessions, err error)
	// Redeems a login token for credentials
	RedeemToken(context.Context, *RedeemTokenPayload) (res *RedeemTokenResult, err error)
	// Deletes all the sessions that have expired
	CleanSessions(context.Context, *CleanSessionsPayload) (err error)
	// Cleans old login tokens from the database
	CleanLoginToken(context.Context, *CleanLoginTokenPayload) (err error)
	// Cleans old account merge tokens from the database
	CleanMergeToken(context.Context, *CleanMergeTokenPayload) (err error)
}

// Auther defines the authorization functions to be implemented by the service.
type Auther interface {
	// APIKeyAuth implements the authorization logic for the APIKey security scheme.
	APIKeyAuth(ctx context.Context, key string, schema *security.APIKeyScheme) (context.Context, error)
	// JWTAuth implements the authorization logic for the JWT security scheme.
	JWTAuth(ctx context.Context, token string, schema *security.JWTScheme) (context.Context, error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "session"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [9]string{"refresh", "logout", "logout-other", "logout-specific", "get-sessions", "redeemToken", "clean-sessions", "clean-login-token", "clean-merge-token"}

// RefreshPayload is the payload type of the session service refresh method.
type RefreshPayload struct {
	XSession *string
	APIKey   *string
}

// RefreshResult is the result type of the session service refresh method.
type RefreshResult struct {
	Authorization *string
	XSession      *string
}

// LogoutPayload is the payload type of the session service logout method.
type LogoutPayload struct {
	Authorization *string
	XSession      *string
	APIKey        *string
}

// LogoutOtherPayload is the payload type of the session service logout-other
// method.
type LogoutOtherPayload struct {
	Authorization *string
	XSession      *string
	APIKey        *string
}

// LogoutSpecificPayload is the payload type of the session service
// logout-specific method.
type LogoutSpecificPayload struct {
	SessionID     *string
	Authorization *string
	XSession      *string
	APIKey        *string
}

// GetSessionsPayload is the payload type of the session service get-sessions
// method.
type GetSessionsPayload struct {
	Authorization *string
	XSession      *string
	APIKey        *string
}

// AllSessions is the result type of the session service get-sessions method.
type AllSessions struct {
	CurrentSession *Session
	OtherSessions  SessionCollection
}

// RedeemTokenPayload is the payload type of the session service redeemToken
// method.
type RedeemTokenPayload struct {
	// A merge token for merging into an account
	Token     string
	UserAgent *string
	APIKey    *string
}

// RedeemTokenResult is the result type of the session service redeemToken
// method.
type RedeemTokenResult struct {
	Authorization *string
	XSession      *string
}

// CleanSessionsPayload is the payload type of the session service
// clean-sessions method.
type CleanSessionsPayload struct {
	Authorization *string
	XSession      *string
	APIKey        *string
}

// CleanLoginTokenPayload is the payload type of the session service
// clean-login-token method.
type CleanLoginTokenPayload struct {
	Authorization *string
	XSession      *string
	APIKey        *string
}

// CleanMergeTokenPayload is the payload type of the session service
// clean-merge-token method.
type CleanMergeTokenPayload struct {
	Authorization *string
	XSession      *string
	APIKey        *string
}

// A session for a user, associated with a specific browser
type Session struct {
	// Unique unchanging session ID
	ID string
	// ID of the user this session is for
	UserID string
	// Time that this session was last used
	LastUsed string
	// The browser and browser version connected with this session
	Browser string
	// The OS of the system where this session was used
	Os string
	// The last IP address where this session was used
	IP string
	// A humanReadable string describing the last known location of the session
	Location string
	// The latitude of the last known location of the session
	Latitude string
	// The longitude of the last known location of the session
	Longitude string
	// Whether the session was from a mobile device
	IsMobile bool
	// The URL of the Google map to show the location, suitable for using in an img
	// tag
	MapURL string
}

type SessionCollection []*Session

// MakeUnauthorized builds a goa.ServiceError from an error.
func MakeUnauthorized(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "Unauthorized",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadRequest builds a goa.ServiceError from an error.
func MakeBadRequest(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "BadRequest",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeInternalServerError builds a goa.ServiceError from an error.
func MakeInternalServerError(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "InternalServerError",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeNotFound builds a goa.ServiceError from an error.
func MakeNotFound(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "NotFound",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeForbidden builds a goa.ServiceError from an error.
func MakeForbidden(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "Forbidden",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// NewAllSessions initializes result type AllSessions from viewed result type
// AllSessions.
func NewAllSessions(vres *sessionviews.AllSessions) *AllSessions {
	var res *AllSessions
	switch vres.View {
	case "default", "":
		res = newAllSessions(vres.Projected)
	}
	return res
}

// NewViewedAllSessions initializes viewed result type AllSessions from result
// type AllSessions using the given view.
func NewViewedAllSessions(res *AllSessions, view string) *sessionviews.AllSessions {
	var vres *sessionviews.AllSessions
	switch view {
	case "default", "":
		p := newAllSessionsView(res)
		vres = &sessionviews.AllSessions{p, "default"}
	}
	return vres
}

// newAllSessions converts projected type AllSessions to service type
// AllSessions.
func newAllSessions(vres *sessionviews.AllSessionsView) *AllSessions {
	res := &AllSessions{}
	if vres.CurrentSession != nil {
		res.CurrentSession = newSession(vres.CurrentSession)
	}
	if vres.OtherSessions != nil {
		res.OtherSessions = newSessionCollection(vres.OtherSessions)
	}
	return res
}

// newAllSessionsView projects result type AllSessions to projected type
// AllSessionsView using the "default" view.
func newAllSessionsView(res *AllSessions) *sessionviews.AllSessionsView {
	vres := &sessionviews.AllSessionsView{}
	if res.CurrentSession != nil {
		vres.CurrentSession = newSessionView(res.CurrentSession)
	}
	if res.OtherSessions != nil {
		vres.OtherSessions = newSessionCollectionView(res.OtherSessions)
	}
	return vres
}

// newSession converts projected type Session to service type Session.
func newSession(vres *sessionviews.SessionView) *Session {
	res := &Session{}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.UserID != nil {
		res.UserID = *vres.UserID
	}
	if vres.LastUsed != nil {
		res.LastUsed = *vres.LastUsed
	}
	if vres.Browser != nil {
		res.Browser = *vres.Browser
	}
	if vres.Os != nil {
		res.Os = *vres.Os
	}
	if vres.IP != nil {
		res.IP = *vres.IP
	}
	if vres.Location != nil {
		res.Location = *vres.Location
	}
	if vres.Latitude != nil {
		res.Latitude = *vres.Latitude
	}
	if vres.Longitude != nil {
		res.Longitude = *vres.Longitude
	}
	if vres.IsMobile != nil {
		res.IsMobile = *vres.IsMobile
	}
	if vres.MapURL != nil {
		res.MapURL = *vres.MapURL
	}
	return res
}

// newSessionView projects result type Session to projected type SessionView
// using the "default" view.
func newSessionView(res *Session) *sessionviews.SessionView {
	vres := &sessionviews.SessionView{
		ID:        &res.ID,
		UserID:    &res.UserID,
		LastUsed:  &res.LastUsed,
		Browser:   &res.Browser,
		Os:        &res.Os,
		IP:        &res.IP,
		Location:  &res.Location,
		Latitude:  &res.Latitude,
		Longitude: &res.Longitude,
		IsMobile:  &res.IsMobile,
		MapURL:    &res.MapURL,
	}
	return vres
}

// newSessionCollection converts projected type SessionCollection to service
// type SessionCollection.
func newSessionCollection(vres sessionviews.SessionCollectionView) SessionCollection {
	res := make(SessionCollection, len(vres))
	for i, n := range vres {
		res[i] = newSession(n)
	}
	return res
}

// newSessionCollectionView projects result type SessionCollection to projected
// type SessionCollectionView using the "default" view.
func newSessionCollectionView(res SessionCollection) sessionviews.SessionCollectionView {
	vres := make(sessionviews.SessionCollectionView, len(res))
	for i, n := range res {
		vres[i] = newSessionView(n)
	}
	return vres
}
