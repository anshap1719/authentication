// Code generated by goa v3.0.6, DO NOT EDIT.
//
// password-auth HTTP client CLI support package
//
// Command:
// $ goa gen github.com/anshap1719/authentication/design

package client

import (
	"encoding/json"
	"fmt"
	"unicode/utf8"

	passwordauth "github.com/anshap1719/authentication/controllers/gen/password_auth"
	goa "goa.design/goa/v3/pkg"
)

// BuildRegisterPayload builds the payload for the password-auth register
// endpoint from CLI flags.
func BuildRegisterPayload(passwordAuthRegisterBody string, passwordAuthRegisterAuthorization string, passwordAuthRegisterXSession string, passwordAuthRegisterAPIKey string) (*passwordauth.RegisterParams, error) {
	var err error
	var body RegisterRequestBody
	{
		err = json.Unmarshal([]byte(passwordAuthRegisterBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, example of valid JSON:\n%s", "'{\n      \"email\": \"julius@rolfson.com\",\n      \"firstName\": \"ol\",\n      \"gRecaptchaResponse\": \"Nostrum sed eaque esse in.\",\n      \"lastName\": \"6vg\",\n      \"password\": \"rta\",\n      \"phone\": \"Aut sunt voluptatem laboriosam ex voluptatem.\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))

		if utf8.RuneCountInString(body.FirstName) < 2 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.firstName", body.FirstName, utf8.RuneCountInString(body.FirstName), 2, true))
		}
		if utf8.RuneCountInString(body.FirstName) > 50 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.firstName", body.FirstName, utf8.RuneCountInString(body.FirstName), 50, false))
		}
		if utf8.RuneCountInString(body.LastName) > 50 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.lastName", body.LastName, utf8.RuneCountInString(body.LastName), 50, false))
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.password", body.Password, "^.*[\\w].*$"))
		if utf8.RuneCountInString(body.Password) < 6 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.password", body.Password, utf8.RuneCountInString(body.Password), 6, true))
		}
		if utf8.RuneCountInString(body.Password) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.password", body.Password, utf8.RuneCountInString(body.Password), 100, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var authorization *string
	{
		if passwordAuthRegisterAuthorization != "" {
			authorization = &passwordAuthRegisterAuthorization
		}
	}
	var xSession *string
	{
		if passwordAuthRegisterXSession != "" {
			xSession = &passwordAuthRegisterXSession
		}
	}
	var aPIKey *string
	{
		if passwordAuthRegisterAPIKey != "" {
			aPIKey = &passwordAuthRegisterAPIKey
		}
	}
	v := &passwordauth.RegisterParams{
		Email:              body.Email,
		FirstName:          body.FirstName,
		LastName:           body.LastName,
		Password:           body.Password,
		Phone:              body.Phone,
		GRecaptchaResponse: body.GRecaptchaResponse,
	}
	v.Authorization = authorization
	v.XSession = xSession
	v.APIKey = aPIKey
	return v, nil
}

// BuildLoginPayload builds the payload for the password-auth login endpoint
// from CLI flags.
func BuildLoginPayload(passwordAuthLoginBody string, passwordAuthLoginToken string, passwordAuthLoginAPIKey string) (*passwordauth.LoginParams, error) {
	var err error
	var body LoginRequestBody
	{
		err = json.Unmarshal([]byte(passwordAuthLoginBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, example of valid JSON:\n%s", "'{\n      \"TwoFactor\": \"lqw\",\n      \"email\": \"kody_dooley@lebsack.name\",\n      \"password\": \"jru\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))

		err = goa.MergeErrors(err, goa.ValidatePattern("body.password", body.Password, "^.*[\\w].*$"))
		if utf8.RuneCountInString(body.Password) < 6 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.password", body.Password, utf8.RuneCountInString(body.Password), 6, true))
		}
		if utf8.RuneCountInString(body.Password) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.password", body.Password, utf8.RuneCountInString(body.Password), 100, false))
		}
		if body.TwoFactor != nil {
			if utf8.RuneCountInString(*body.TwoFactor) < 6 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.TwoFactor", *body.TwoFactor, utf8.RuneCountInString(*body.TwoFactor), 6, true))
			}
		}
		if body.TwoFactor != nil {
			if utf8.RuneCountInString(*body.TwoFactor) > 8 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.TwoFactor", *body.TwoFactor, utf8.RuneCountInString(*body.TwoFactor), 8, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var token *string
	{
		if passwordAuthLoginToken != "" {
			token = &passwordAuthLoginToken
		}
	}
	var aPIKey *string
	{
		if passwordAuthLoginAPIKey != "" {
			aPIKey = &passwordAuthLoginAPIKey
		}
	}
	v := &passwordauth.LoginParams{
		Email:     body.Email,
		Password:  body.Password,
		TwoFactor: body.TwoFactor,
	}
	v.Token = token
	v.APIKey = aPIKey
	return v, nil
}

// BuildRemovePayload builds the payload for the password-auth remove endpoint
// from CLI flags.
func BuildRemovePayload(passwordAuthRemoveAuthorization string, passwordAuthRemoveXSession string, passwordAuthRemoveAPIKey string) (*passwordauth.RemovePayload, error) {
	var authorization *string
	{
		if passwordAuthRemoveAuthorization != "" {
			authorization = &passwordAuthRemoveAuthorization
		}
	}
	var xSession *string
	{
		if passwordAuthRemoveXSession != "" {
			xSession = &passwordAuthRemoveXSession
		}
	}
	var aPIKey *string
	{
		if passwordAuthRemoveAPIKey != "" {
			aPIKey = &passwordAuthRemoveAPIKey
		}
	}
	payload := &passwordauth.RemovePayload{
		Authorization: authorization,
		XSession:      xSession,
		APIKey:        aPIKey,
	}
	return payload, nil
}

// BuildChangePasswordPayload builds the payload for the password-auth
// change-password endpoint from CLI flags.
func BuildChangePasswordPayload(passwordAuthChangePasswordBody string, passwordAuthChangePasswordAuthorization string, passwordAuthChangePasswordXSession string, passwordAuthChangePasswordAPIKey string) (*passwordauth.ChangePasswordParams, error) {
	var err error
	var body ChangePasswordRequestBody
	{
		err = json.Unmarshal([]byte(passwordAuthChangePasswordBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, example of valid JSON:\n%s", "'{\n      \"newPassword\": \"0gq\",\n      \"oldPassword\": \"v2m\"\n   }'")
		}
		if body.OldPassword != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.oldPassword", *body.OldPassword, "^.*[\\w].*$"))
		}
		if body.OldPassword != nil {
			if utf8.RuneCountInString(*body.OldPassword) < 6 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.oldPassword", *body.OldPassword, utf8.RuneCountInString(*body.OldPassword), 6, true))
			}
		}
		if body.OldPassword != nil {
			if utf8.RuneCountInString(*body.OldPassword) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.oldPassword", *body.OldPassword, utf8.RuneCountInString(*body.OldPassword), 100, false))
			}
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.newPassword", body.NewPassword, "^.*[\\w].*$"))
		if utf8.RuneCountInString(body.NewPassword) < 6 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.newPassword", body.NewPassword, utf8.RuneCountInString(body.NewPassword), 6, true))
		}
		if utf8.RuneCountInString(body.NewPassword) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.newPassword", body.NewPassword, utf8.RuneCountInString(body.NewPassword), 100, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var authorization string
	{
		authorization = passwordAuthChangePasswordAuthorization
	}
	var xSession string
	{
		xSession = passwordAuthChangePasswordXSession
	}
	var aPIKey *string
	{
		if passwordAuthChangePasswordAPIKey != "" {
			aPIKey = &passwordAuthChangePasswordAPIKey
		}
	}
	v := &passwordauth.ChangePasswordParams{
		OldPassword: body.OldPassword,
		NewPassword: body.NewPassword,
	}
	v.Authorization = authorization
	v.XSession = xSession
	v.APIKey = aPIKey
	return v, nil
}

// BuildResetPayload builds the payload for the password-auth reset endpoint
// from CLI flags.
func BuildResetPayload(passwordAuthResetEmail string, passwordAuthResetAPIKey string) (*passwordauth.ResetPayload, error) {
	var email string
	{
		email = passwordAuthResetEmail
	}
	var aPIKey *string
	{
		if passwordAuthResetAPIKey != "" {
			aPIKey = &passwordAuthResetAPIKey
		}
	}
	payload := &passwordauth.ResetPayload{
		Email:  &email,
		APIKey: aPIKey,
	}
	return payload, nil
}

// BuildConfirmResetPayload builds the payload for the password-auth
// confirm-reset endpoint from CLI flags.
func BuildConfirmResetPayload(passwordAuthConfirmResetBody string, passwordAuthConfirmResetAPIKey string) (*passwordauth.ResetPasswordParams, error) {
	var err error
	var body ConfirmResetRequestBody
	{
		err = json.Unmarshal([]byte(passwordAuthConfirmResetBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, example of valid JSON:\n%s", "'{\n      \"newPassword\": \"xj1\",\n      \"resetCode\": \"Exercitationem porro autem aut.\",\n      \"userID\": \"Corrupti dolore facilis iure et.\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.newPassword", body.NewPassword, "^.*[\\w].*$"))
		if utf8.RuneCountInString(body.NewPassword) < 6 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.newPassword", body.NewPassword, utf8.RuneCountInString(body.NewPassword), 6, true))
		}
		if utf8.RuneCountInString(body.NewPassword) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.newPassword", body.NewPassword, utf8.RuneCountInString(body.NewPassword), 100, false))
		}
		if err != nil {
			return nil, err
		}
	}
	var aPIKey *string
	{
		if passwordAuthConfirmResetAPIKey != "" {
			aPIKey = &passwordAuthConfirmResetAPIKey
		}
	}
	v := &passwordauth.ResetPasswordParams{
		ResetCode:   body.ResetCode,
		UserID:      body.UserID,
		NewPassword: body.NewPassword,
	}
	v.APIKey = aPIKey
	return v, nil
}

// BuildCheckEmailAvailablePayload builds the payload for the password-auth
// check-email-available endpoint from CLI flags.
func BuildCheckEmailAvailablePayload(passwordAuthCheckEmailAvailableEmail string, passwordAuthCheckEmailAvailableAPIKey string) (*passwordauth.CheckEmailAvailablePayload, error) {
	var email *string
	{
		if passwordAuthCheckEmailAvailableEmail != "" {
			email = &passwordAuthCheckEmailAvailableEmail
		}
	}
	var aPIKey *string
	{
		if passwordAuthCheckEmailAvailableAPIKey != "" {
			aPIKey = &passwordAuthCheckEmailAvailableAPIKey
		}
	}
	payload := &passwordauth.CheckEmailAvailablePayload{
		Email:  email,
		APIKey: aPIKey,
	}
	return payload, nil
}

// BuildCheckPhoneAvailablePayload builds the payload for the password-auth
// check-phone-available endpoint from CLI flags.
func BuildCheckPhoneAvailablePayload(passwordAuthCheckPhoneAvailablePhone string, passwordAuthCheckPhoneAvailableAPIKey string) (*passwordauth.CheckPhoneAvailablePayload, error) {
	var phone *string
	{
		if passwordAuthCheckPhoneAvailablePhone != "" {
			phone = &passwordAuthCheckPhoneAvailablePhone
		}
	}
	var aPIKey *string
	{
		if passwordAuthCheckPhoneAvailableAPIKey != "" {
			aPIKey = &passwordAuthCheckPhoneAvailableAPIKey
		}
	}
	payload := &passwordauth.CheckPhoneAvailablePayload{
		Phone:  phone,
		APIKey: aPIKey,
	}
	return payload, nil
}
